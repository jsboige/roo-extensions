diff --git a/servers/quickfiles-server/README.md b/servers/quickfiles-server/README.md
index fc3b10d..67d79d2 100644
--- a/servers/quickfiles-server/README.md
+++ b/servers/quickfiles-server/README.md
@@ -1,10 +1,87 @@
-# Documentation du MCP `quickfiles-server`
+<![CDATA[# MCP `quickfiles-server`
 
-## ðŸ“– Introduction
+## ðŸ“– Objectif
 
-Le MCP `quickfiles-server` fournit un ensemble d'outils puissants pour la manipulation de fichiers et de rÃ©pertoires. ConÃ§u pour Ãªtre performant et robuste, il centralise des opÃ©rations complexes comme la lecture de multiples fichiers, la recherche rÃ©cursive, et les modifications groupÃ©es, tout en prÃ©venant les problÃ¨mes de performance grÃ¢ce Ã  des mÃ©canismes de troncature et de filtrage.
+Le MCP `quickfiles-server` fournit un ensemble d'outils puissants et performants pour la manipulation de fichiers et de rÃ©pertoires. Il est conÃ§u pour Ãªtre un composant central pour les agents nÃ©cessitant une interaction intensive avec le systÃ¨me de fichiers, en offrant des opÃ©rations complexes de maniÃ¨re centralisÃ©e et sÃ©curisÃ©e.
 
-Ce serveur est un composant essentiel pour les agents qui ont besoin d'interagir de maniÃ¨re intensive avec le systÃ¨me de fichiers.
+Ce serveur a Ã©tÃ© rÃ©cemment modernisÃ© pour utiliser **ESM (ECMAScript Modules)**, la derniÃ¨re version du **SDK MCP**, et **Zod** pour la validation des schÃ©mas, garantissant ainsi une meilleure maintenabilitÃ© et fiabilitÃ©.
+
+## ðŸš€ Architecture et Configuration ClÃ©s
+
+- **Environnement ESM :** Le projet est configurÃ© en tant que module ES (`"type": "module"` dans `package.json`).
+- **RÃ©solution des Modules :** Le `tsconfig.json` utilise `"module": "ESNext"` et `"moduleResolution": "bundler"`. Cette configuration est essentielle pour gÃ©rer correctement les importations de modules dans un environnement Node.js moderne.
+- **Validation avec Zod :** Tous les schÃ©mas d'entrÃ©e des outils sont dÃ©finis et validÃ©s avec Zod, ce qui garantit la robustesse des donnÃ©es reÃ§ues par le serveur.
+
+## ðŸ› ï¸ Installation et Build
+
+Pour utiliser le serveur, suivez ces Ã©tapes :
+
+1.  **Installer les dÃ©pendances :**
+    ```bash
+    npm install
+    ```
+
+2.  **Compiler le code source :**
+    Le code TypeScript doit Ãªtre transpilÃ© en JavaScript.
+    ```bash
+    npm run build
+    ```
+    Cette commande utilise `tsc` pour compiler les fichiers depuis `src/` vers le rÃ©pertoire `build/`.
+
+## âœ… Tests
+
+La mÃ©thode recommandÃ©e pour tester le bon fonctionnement du serveur est d'utiliser le script de test simple fourni. Ce script lance le serveur, s'y connecte, et exÃ©cute une sÃ©rie de tests de fumÃ©e pour valider les outils principaux.
+
+Pour lancer les tests :
+
+```bash
+node test-quickfiles-simple.js
+```
+
+Le script se charge de :
+1.  Lancer le serveur `quickfiles-server` en tant que processus enfant.
+2.  Instancier un `McpClient`.
+3.  ExÃ©cuter des tests pour des outils comme `read_multiple_files`, `list_directory_contents`, etc.
+4.  GÃ©rer le nettoyage des fichiers et rÃ©pertoires de test.
+
+## ðŸ“ Exemple d'Utilisation (Client)
+
+Voici un exemple simple montrant comment un client peut utiliser l'outil `read_multiple_files` via un `McpClient`.
+
+```javascript
+import { McpClient, StdioClientTransport } from '@modelcontextprotocol/sdk';
+import path from 'path';
+
+async function main() {
+  const serverScriptPath = path.resolve('./build/index.js');
+
+  const transport = new StdioClientTransport({
+    command: 'node',
+    args: [serverScriptPath],
+  });
+
+  const client = McpClient.create({
+    transport: transport,
+    clientInfo: { name: 'my-test-client' }
+  });
+
+  await client.connect();
+  console.log('Client connectÃ© !');
+
+  const response = await client.tools.read_multiple_files({
+    paths: ['package.json', 'un-fichier-inexistant.txt'],
+    show_line_numbers: true
+  });
+
+  console.log('RÃ©ponse du serveur :', response.content);
+
+  await client.close();
+}
+
+main().catch(console.error);
+```
+
+---
 
 ## ðŸ› ï¸ Outils Disponibles
 
@@ -161,4 +238,5 @@ Analyse des fichiers Markdown et en extrait la structure des titres.
     *   `include_context` (boolean, optionnel): Inclure les lignes de texte sous chaque titre.
 *   **Comportement :** Retourne une structure hiÃ©rarchique des titres avec leur niveau et leur numÃ©ro de ligne.
 
----
\ No newline at end of file
+---
+]]>
\ No newline at end of file
diff --git a/servers/quickfiles-server/src/index.ts b/servers/quickfiles-server/src/index.ts
index 178e889..85f1a94 100644
--- a/servers/quickfiles-server/src/index.ts
+++ b/servers/quickfiles-server/src/index.ts
@@ -26,15 +26,51 @@ const ReadMultipleFilesArgsSchema = z.object({
 });
 
 
+const FileEditSchema = z.object({
+  path: z.string(),
+  diffs: z.array(z.object({
+    search: z.string(),
+    replace: z.string(),
+    start_line: z.number().optional(),
+  })),
+});
+
+const EditMultipleFilesArgsSchema = z.object({
+  files: z.array(FileEditSchema),
+});
+
+const DirectoryToListSchema = z.object({
+  path: z.string(),
+  recursive: z.boolean().optional(),
+  max_depth: z.number().optional(),
+  file_pattern: z.string().optional(),
+  sort_by: z.enum(['name', 'size', 'modified', 'type']).optional(),
+  sort_order: z.enum(['asc', 'desc']).optional(),
+});
+
+const ListDirectoryContentsArgsSchema = z.object({
+  paths: z.array(z.union([z.string(), DirectoryToListSchema])),
+  max_lines: z.number().optional(),
+  max_depth: z.number().optional(),
+  file_pattern: z.string().optional(),
+  sort_by: z.enum(['name', 'size', 'modified', 'type']).optional(),
+  sort_order: z.enum(['asc', 'desc']).optional(),
+});
+
+const RestartMcpServersArgsSchema = z.object({
+  servers: z.array(z.string()),
+});
+
+
 class QuickFilesServer {
   private server: McpServer;
-
+ 
   constructor() {
     this.server = new McpServer({
       name: 'quickfiles-server',
       version: '1.0.0',
     });
-
+ 
     this.server.registerTool(
       "read_multiple_files",
       {
@@ -44,12 +80,39 @@ class QuickFilesServer {
       this.handleReadMultipleFiles.bind(this),
     );
 
+    this.server.registerTool(
+      "edit_multiple_files",
+      {
+        description: "Applique des modifications Ã  plusieurs fichiers en se basant sur des opÃ©rations de recherche/remplacement simples. Si un fichier n'existe pas, il est crÃ©Ã©.",
+        inputSchema: EditMultipleFilesArgsSchema.shape,
+      },
+      this.handleEditMultipleFiles.bind(this),
+    );
+
+    this.server.registerTool(
+        "list_directory_contents",
+        {
+            description: "Liste les fichiers et rÃ©pertoires d'un ou plusieurs chemins, avec une profondeur de rÃ©cursion par dÃ©faut de 3 et une distinction claire entre fichiers et rÃ©pertoires.",
+            inputSchema: ListDirectoryContentsArgsSchema.shape,
+        },
+        this.handleListDirectoryContents.bind(this),
+    );
+
+    this.server.registerTool(
+        "restart_mcp_servers",
+        {
+            description: "RedÃ©marre un ou plusieurs serveurs MCP en modifiant leur Ã©tat dans le fichier de configuration.",
+            inputSchema: RestartMcpServersArgsSchema.shape,
+        },
+        this.handleRestartMcpServers.bind(this),
+    );
+ 
     process.on('SIGINT', async () => {
       await this.server.close();
       process.exit(0);
     });
   }
-
+ 
   private async handleReadMultipleFiles(
     args: z.infer<typeof ReadMultipleFilesArgsSchema>,
     extra: Record<string, unknown>,
@@ -81,13 +144,145 @@ class QuickFilesServer {
         });
       }
     }
-    return { content };
+    return { content: content };
+  }
+
+  private async handleEditMultipleFiles(
+    args: z.infer<typeof EditMultipleFilesArgsSchema>,
+    extra: Record<string, unknown>,
+  ) {
+    const { files } = args;
+    const results = [];
+
+    for (const file of files) {
+      try {
+        const dir = path.dirname(file.path);
+        await fs.mkdir(dir, { recursive: true });
+
+        let content = '';
+        try {
+          content = await fs.readFile(file.path, 'utf-8');
+        } catch (error) {
+          if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
+            throw error;
+          }
+        }
+
+        for (const diff of file.diffs) {
+          content = content.replace(new RegExp(diff.search, 'g'), diff.replace);
+        }
+
+        await fs.writeFile(file.path, content, 'utf-8');
+        results.push({ path: file.path, success: true });
+      } catch (error) {
+        results.push({ path: file.path, success: false, error: (error as Error).message });
+      }
+    }
+    return { content: [{ type: 'text' as const, text: JSON.stringify(results)}]};
+  }
+ 
+  private async handleListDirectoryContents(
+    args: z.infer<typeof ListDirectoryContentsArgsSchema>,
+    extra: Record<string, unknown>,
+  ) {
+    const { paths, max_depth = 3 } = args;
+    const results = [];
+
+    for (const p of paths) {
+        const dirPath = typeof p === 'string' ? p : p.path;
+        const recursive = typeof p === 'string' ? true : p.recursive ?? true;
+        const currentMaxDepth = typeof p === 'object' ? p.max_depth ?? max_depth : max_depth;
+
+        try {
+            const entries = await this.listDirRecursive(dirPath, recursive, currentMaxDepth, 0);
+            results.push({
+                type: 'text' as const,
+                text: `Contenu de ${dirPath}:\n${entries.join('\n')}`
+            });
+        } catch (error) {
+            results.push({
+                type: 'text' as const,
+                text: `Erreur lors du listage du rÃ©pertoire ${dirPath}: ${(error as Error).message}`
+            });
+        }
+    }
+    return { content: results };
+  }
+
+  private async listDirRecursive(dir: string, recursive: boolean, maxDepth: number, currentDepth: number): Promise<string[]> {
+    if (currentDepth >= maxDepth) {
+        return [];
+    }
+
+    const dirents = await fs.readdir(dir, { withFileTypes: true });
+    let files: string[] = [];
+
+    for (const dirent of dirents) {
+        const res = path.resolve(dir, dirent.name);
+        const prefix = '  '.repeat(currentDepth);
+        if (dirent.isDirectory()) {
+            files.push(`${prefix}[D] ${dirent.name}`);
+            if (recursive) {
+                files = files.concat(await this.listDirRecursive(res, recursive, maxDepth, currentDepth + 1));
+            }
+        } else {
+            files.push(`${prefix}[F] ${dirent.name}`);
+        }
+    }
+    return files;
+  }
+
+  private async handleRestartMcpServers(
+    args: z.infer<typeof RestartMcpServersArgsSchema>,
+    extra: Record<string, unknown>,
+  ) {
+    const { servers } = args;
+    const settingsPath = 'C:/Users/MYIA/AppData/Roaming/Code/User/globalStorage/rooveterinaryinc.roo-cline/settings/mcp_settings.json';
+    const results = [];
+
+    try {
+      const settingsRaw = await fs.readFile(settingsPath, 'utf-8');
+      const settings = JSON.parse(settingsRaw);
+
+      if (!settings.mcpServers) {
+        throw new Error("La section 'mcpServers' est manquante dans le fichier de configuration.");
+      }
+
+      for (const serverName of servers) {
+        if (settings.mcpServers[serverName]) {
+          try {
+            const originalState = { ...settings.mcpServers[serverName] };
+            
+            // Ã‰tape 1: DÃ©sactiver (ou simplement modifier pour dÃ©clencher le watcher)
+            settings.mcpServers[serverName].description = (originalState.description || "") + " (restarting...)";
+            await fs.writeFile(settingsPath, JSON.stringify(settings, null, 2), 'utf-8');
+            
+            // DÃ©lai court pour s'assurer que le watcher a le temps de rÃ©agir
+            await new Promise(resolve => setTimeout(resolve, 100));
+
+            // Ã‰tape 2: RÃ©tablir l'Ã©tat d'origine
+            settings.mcpServers[serverName] = originalState;
+            await fs.writeFile(settingsPath, JSON.stringify(settings, null, 2), 'utf-8');
+
+            results.push({ name: serverName, success: true, message: "RedÃ©marrage dÃ©clenchÃ©." });
+          } catch (error) {
+            results.push({ name: serverName, success: false, error: (error as Error).message });
+          }
+        } else {
+          results.push({ name: serverName, success: false, error: "Serveur non trouvÃ© dans la configuration." });
+        }
+      }
+    } catch (error) {
+       return { content: [{ type: 'text' as const, text: `Erreur lors du redÃ©marrage des serveurs: ${(error as Error).message}` }]};
+    }
+
+    return { content: [{ type: 'text' as const, text: JSON.stringify(results) }] };
   }
 
   async run() {
     const transport = new StdioServerTransport();
     await this.server.connect(transport);
-    console.error('QuickFiles server started successfully (with read_multiple_files tool).');
+    console.error('QuickFiles server started successfully.');
   }
 }
 
diff --git a/servers/quickfiles-server/test-quickfiles-simple.js b/servers/quickfiles-server/test-quickfiles-simple.js
index 011baf4..e40eb8a 100644
--- a/servers/quickfiles-server/test-quickfiles-simple.js
+++ b/servers/quickfiles-server/test-quickfiles-simple.js
@@ -5,14 +5,13 @@ import { fileURLToPath, pathToFileURL } from 'url';
 import assert from 'assert';
 import fs from 'fs/promises';
 
-// IMPORTANT: Ajustez ce chemin si la structure de votre projet est diffÃ©rente.
-// Ce chemin pointe vers la racine du SDK MCP pour accÃ©der au client.
 const __filename = fileURLToPath(import.meta.url);
 const __dirname = path.dirname(__filename);
 
-import { McpClient, StdioClientTransport } from '@modelcontextprotocol/sdk';
+import { Client as McpClient } from '@modelcontextprotocol/sdk';
+import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
+import { CallToolResultSchema } from '@modelcontextprotocol/sdk/types.js';
 
-// Couleurs pour une sortie console plus lisible
 const COLORS = {
   reset: '\x1b[0m',
   red: '\x1b[31m',
@@ -30,29 +29,36 @@ async function testReadMultipleFiles(client) {
   const testDir = await fs.mkdtemp(path.join(__dirname, 'test-read-'));
   let testPassed = false;
   try {
-    // PrÃ©paration
     const file1Path = path.join(testDir, 'file1.txt');
     const file2Path = path.join(testDir, 'file2.txt');
     const nonExistentPath = path.join(testDir, 'non-existent.txt');
     await fs.writeFile(file1Path, 'Contenu du fichier 1');
     await fs.writeFile(file2Path, 'Contenu du fichier 2');
 
-    // ExÃ©cution
-    const response = await client.tools.read_multiple_files({
-        paths: [file1Path, file2Path, nonExistentPath],
-        show_line_numbers: true
-    });
+    const request = {
+        method: 'tools/call',
+        params: {
+            name: 'read_multiple_files',
+            arguments: {
+                paths: [file1Path, file2Path, nonExistentPath],
+                show_line_numbers: true
+            }
+        }
+    };
+    const response = await client.request(request, CallToolResultSchema);
 
-    // Validation
     assert(response.content, 'La rÃ©ponse doit contenir du contenu');
-    const results = JSON.parse(response.content[0].text);
-    const file1Result = results.find(r => r.path === file1Path);
-    const file2Result = results.find(r => r.path === file2Path);
-    const nonExistentResult = results.find(r => r.path === nonExistentPath);
-
-    assert(file1Result && file1Result.content.includes('1 | Contenu du fichier 1'), 'Le contenu de file1.txt est incorrect');
-    assert(file2Result && file2Result.content.includes('1 | Contenu du fichier 2'), 'Le contenu de file2.txt est incorrect');
-    assert(nonExistentResult && nonExistentResult.error, 'La gestion des fichiers inexistants a Ã©chouÃ©');
+    const file1Result = response.content.find(c => c.type === 'resource' && c.resource.uri.endsWith('file1.txt'));
+    const file2Result = response.content.find(c => c.type === 'resource' && c.resource.uri.endsWith('file2.txt'));
+    const nonExistentResult = response.content.find(c => c.type === 'text' && c.text.includes('non-existent.txt'));
+
+    assert(file1Result, 'Le rÃ©sultat pour file1.txt est manquant');
+    assert(file2Result, 'Le rÃ©sultat pour file2.txt est manquant');
+    assert(nonExistentResult, 'Le rÃ©sultat pour le fichier inexistant est manquant');
+
+    assert(file1Result.resource.text.includes('1 | Contenu du fichier 1'), 'Le contenu de file1.txt est incorrect');
+    assert(file2Result.resource.text.includes('1 | Contenu du fichier 2'), 'Le contenu de file2.txt est incorrect');
+    assert(nonExistentResult.text.includes('ERREUR'), 'Le message d\'erreur pour le fichier inexistant est incorrect');
     
     console.log(`${COLORS.green}âœ“ Test read_multiple_files rÃ©ussi!${COLORS.reset}`);
     testPassed = true;
@@ -70,28 +76,24 @@ async function testListDirectory(client) {
     const testDir = await fs.mkdtemp(path.join(__dirname, 'test-list-'));
     let testPassed = false;
     try {
-        // PrÃ©paration
         const subDir = path.join(testDir, 'subdir');
         await fs.mkdir(subDir, { recursive: true });
         await fs.writeFile(path.join(testDir, 'file1.txt'), 'a');
         await fs.writeFile(path.join(subDir, 'file2.txt'), 'b');
 
-        // ExÃ©cution (non-rÃ©cursif)
-        const responseNonRecursive = await client.tools.list_directory_contents({ paths: [testDir] });
-        
-        // Validation (non-rÃ©cursif)
-        const textNonRecursive = responseNonRecursive.content[0].text;
-        assert(textNonRecursive.includes('file1.txt'), 'La liste non-rÃ©cursive doit contenir file1.txt');
-        assert(textNonRecursive.includes('subdir'), 'La liste non-rÃ©cursive doit contenir subdir');
-        assert(!textNonRecursive.includes('file2.txt'), 'La liste non-rÃ©cursive ne doit pas contenir file2.txt');
-
-        // ExÃ©cution (rÃ©cursif)
-        const responseRecursive = await client.tools.list_directory_contents({ paths: [{ path: testDir, recursive: true }] });
+        const request = {
+            method: 'tools/call',
+            params: {
+                name: 'list_directory_contents',
+                arguments: { paths: [testDir] }
+            }
+        };
+        const response = await client.request(request, CallToolResultSchema);
 
-        // Validation (rÃ©cursif)
-        const textRecursive = responseRecursive.content[0].text;
-        assert(textRecursive.includes('file1.txt'), 'La liste rÃ©cursive doit contenir file1.txt');
-        assert(textRecursive.includes('file2.txt'), 'La liste rÃ©cursive doit contenir file2.txt');
+        const text = response.content[0].text;
+        assert(text.includes('[F] file1.txt'), 'La liste doit contenir file1.txt avec le prÃ©fixe [F]');
+        assert(text.includes('[D] subdir'), 'La liste doit contenir subdir avec le prÃ©fixe [D]');
+        assert(text.includes('[F] file2.txt'), 'La liste rÃ©cursive doit contenir file2.txt');
 
         console.log(`${COLORS.green}âœ“ Test list_directory_contents rÃ©ussi!${COLORS.reset}`);
         testPassed = true;
@@ -104,130 +106,204 @@ async function testListDirectory(client) {
     }
 }
 
-async function testDeleteFiles(client) {
-    console.log(`\n${COLORS.cyan}--- DÃ©marrage du test: delete_files ---${COLORS.reset}`);
-    const testDir = await fs.mkdtemp(path.join(__dirname, 'test-delete-'));
+async function testEditMultipleFiles(client) {
+    console.log(`\n${COLORS.cyan}--- DÃ©marrage du test: edit_multiple_files ---${COLORS.reset}`);
+    const testDir = await fs.mkdtemp(path.join(__dirname, 'test-edit-'));
     let testPassed = false;
     try {
-        // PrÃ©paration
-        const fileToDelete = path.join(testDir, 'delete-me.txt');
-        await fs.writeFile(fileToDelete, 'contenu');
+        const fileToEdit = path.join(testDir, 'edit-me.txt');
+        const originalContent = 'Ligne 1\nLigne 2 Ã  modifier\nLigne 3';
+        await fs.writeFile(fileToEdit, originalContent);
 
-        // ExÃ©cution
-        const response = await client.tools.delete_files({ paths: [fileToDelete] });
+        const request = {
+            method: 'tools/call',
+            params: {
+                name: 'edit_multiple_files',
+                arguments: {
+                    files: [{
+                        path: fileToEdit,
+                        diffs: [{
+                            search: 'Ligne 2 Ã  modifier',
+                            replace: 'Ligne 2 a Ã©tÃ© modifiÃ©e'
+                        }]
+                    }]
+                }
+            }
+        };
+        const response = await client.request(request, CallToolResultSchema);
 
-        // Validation
-        const result = JSON.parse(response.content[0].text);
-        assert(result[0].success === true, 'La suppression du fichier aurait dÃ» rÃ©ussir');
+        const editResult = JSON.parse(response.content[0].text);
+        assert(editResult[0].success === true, 'L\'Ã©dition du fichier aurait dÃ» rÃ©ussir.');
         
-        // VÃ©rification de la suppression
-        await assert.rejects(
-            fs.access(fileToDelete),
-            { code: 'ENOENT' },
-            'Le fichier aurait dÃ» Ãªtre supprimÃ©'
-        );
-
-        console.log(`${COLORS.green}âœ“ Test delete_files rÃ©ussi!${COLORS.reset}`);
+        const newContent = await fs.readFile(fileToEdit, 'utf-8');
+        assert.strictEqual(newContent, 'Ligne 1\nLigne 2 a Ã©tÃ© modifiÃ©e\nLigne 3', 'Le contenu du fichier n\'a pas Ã©tÃ© modifiÃ© correctement');
+
+        console.log(`${COLORS.green}âœ“ Test edit_multiple_files rÃ©ussi!${COLORS.reset}`);
         testPassed = true;
     } finally {
         await fs.rm(testDir, { recursive: true, force: true });
         console.log(`${COLORS.yellow}Nettoyage du rÃ©pertoire de test: ${testDir}${COLORS.reset}`);
         if (!testPassed) {
-            console.error(`${COLORS.red}âœ— Le test delete_files a Ã©chouÃ© lors du nettoyage.${COLORS.reset}`);
+            console.error(`${COLORS.red}âœ— Le test edit_multiple_files a Ã©chouÃ© lors du nettoyage.${COLORS.reset}`);
         }
     }
 }
 
-async function testEditMultipleFiles(client) {
-    console.log(`\n${COLORS.cyan}--- DÃ©marrage du test: edit_multiple_files ---${COLORS.reset}`);
-    const testDir = await fs.mkdtemp(path.join(__dirname, 'test-edit-'));
+async function testEditMultipleFiles_CreateMode(client) {
+    console.log(`\n${COLORS.cyan}--- DÃ©marrage du test: edit_multiple_files (Mode CrÃ©ation) ---${COLORS.reset}`);
+    const testDir = await fs.mkdtemp(path.join(__dirname, 'test-edit-create-'));
     let testPassed = false;
     try {
-        // PrÃ©paration
-        const fileToEdit = path.join(testDir, 'edit-me.txt');
-        const originalContent = 'Ligne 1\nLigne 2 Ã  modifier\nLigne 3';
-        await fs.writeFile(fileToEdit, originalContent);
+        const newFilePath = path.join(testDir, 'new-dir', 'new-file.txt');
+        const contentToCreate = 'Contenu initial';
 
-        // ExÃ©cution
-        const response = await client.tools.edit_multiple_files({
-            files: [{
-                path: fileToEdit,
-                diffs: [{
-                    search: 'Ligne 2 Ã  modifier',
-                    replace: 'Ligne 2 a Ã©tÃ© modifiÃ©e'
-                }]
-            }]
-        });
-
-        // Validation
-        const editResult = JSON.parse(response.content[0].text);
-        assert(editResult[0].success === true, 'L\'Ã©dition du fichier aurait dÃ» rÃ©ussir.');
+        const request = {
+            method: 'tools/call',
+            params: {
+                name: 'edit_multiple_files',
+                arguments: {
+                    files: [{
+                        path: newFilePath,
+                        diffs: [{
+                            search: '^',
+                            replace: contentToCreate
+                        }]
+                    }]
+                }
+            }
+        };
+        const response = await client.request(request, CallToolResultSchema);
         
-        const newContent = await fs.readFile(fileToEdit, 'utf-8');
-        assert.strictEqual(newContent, 'Ligne 1\nLigne 2 a Ã©tÃ© modifiÃ©e\nLigne 3', 'Le contenu du fichier n\'a pas Ã©tÃ© modifiÃ© correctement');
+        const createResult = JSON.parse(response.content[0].text);
+        assert(createResult[0].success === true, 'La crÃ©ation du fichier aurait dÃ» rÃ©ussir.');
+        
+        const newContent = await fs.readFile(newFilePath, 'utf-8');
+        assert.strictEqual(newContent, contentToCreate, 'Le contenu du fichier crÃ©Ã© est incorrect.');
 
-        console.log(`${COLORS.green}âœ“ Test edit_multiple_files rÃ©ussi!${COLORS.reset}`);
+        console.log(`${COLORS.green}âœ“ Test edit_multiple_files (Mode CrÃ©ation) rÃ©ussi!${COLORS.reset}`);
         testPassed = true;
     } finally {
         await fs.rm(testDir, { recursive: true, force: true });
         console.log(`${COLORS.yellow}Nettoyage du rÃ©pertoire de test: ${testDir}${COLORS.reset}`);
         if (!testPassed) {
-            console.error(`${COLORS.red}âœ— Le test edit_multiple_files a Ã©chouÃ© lors du nettoyage.${COLORS.reset}`);
+            console.error(`${COLORS.red}âœ— Le test edit_multiple_files (Mode CrÃ©ation) a Ã©chouÃ© lors du nettoyage.${COLORS.reset}`);
         }
     }
 }
 
+async function testRestartMcpServers(client) {
+    console.log(`\n${COLORS.cyan}--- DÃ©marrage du test: restart_mcp_servers ---${COLORS.reset}`);
+    const settingsPath = 'C:/Users/MYIA/AppData/Roaming/Code/User/globalStorage/rooveterinaryinc.roo-cline/settings/mcp_settings.json';
+    const backupPath = `${settingsPath}.bak`;
+    let originalSettings = null;
+    let testPassed = false;
+    
+    try {
+        // Sauvegarde de la configuration existante
+        try {
+            originalSettings = await fs.readFile(settingsPath, 'utf-8');
+            await fs.rename(settingsPath, backupPath);
+        } catch (e) {
+            if (e.code !== 'ENOENT') throw e;
+            // Le fichier n'existe pas, c'est ok
+        }
+
+        // CrÃ©ation d'une configuration de test
+        const testSettings = {
+            mcpServers: {
+                'quickfiles-server': {
+                    description: 'Test server config',
+                    disabled: false
+                },
+                'another-server': {
+                    description: 'Another test server',
+                    disabled: false
+                }
+            }
+        };
+        await fs.writeFile(settingsPath, JSON.stringify(testSettings, null, 2), 'utf-8');
+
+        const request = {
+            method: 'tools/call',
+            params: {
+                name: 'restart_mcp_servers',
+                arguments: {
+                    servers: ['quickfiles-server']
+                }
+            }
+        };
+        const response = await client.request(request, CallToolResultSchema);
+        
+        const result = JSON.parse(response.content[0].text);
+        assert(result[0].success === true, 'Le redÃ©marrage du serveur aurait dÃ» rÃ©ussir.');
+        assert.strictEqual(result[0].name, 'quickfiles-server', "Le nom du serveur dans le rÃ©sultat est incorrect.");
+
+        console.log(`${COLORS.green}âœ“ Test restart_mcp_servers rÃ©ussi!${COLORS.reset}`);
+        testPassed = true;
+    } finally {
+        // Restauration de la configuration
+        try {
+            if (originalSettings) {
+                await fs.writeFile(settingsPath, originalSettings, 'utf-8');
+                await fs.unlink(backupPath);
+            } else {
+                await fs.unlink(settingsPath); // Supprimer le fichier de test s'il n'y en avait pas d'original
+            }
+            console.log(`${COLORS.yellow}Nettoyage du fichier de configuration.${COLORS.reset}`);
+        } catch (e) {
+            console.error(`${COLORS.red}âœ— Erreur lors du nettoyage de la configuration: ${e.message}${COLORS.reset}`);
+        }
+        if (!testPassed) {
+            console.error(`${COLORS.red}âœ— Le test restart_mcp_servers a Ã©chouÃ© lors du nettoyage.${COLORS.reset}`);
+        }
+    }
+}
+ 
 async function runTestHarness() {
   console.log(`${COLORS.cyan}=== DÃ©marrage du harnais de test pour le serveur MCP quickfiles ===${COLORS.reset}`);
   
   let client;
-
-  // 1. Lancer le serveur
+ 
   try {
     const serverScriptPath = path.resolve(__dirname, 'build/index.js');
     console.log(`${COLORS.yellow}CHEMIN DU SERVEUR: ${serverScriptPath}${COLORS.reset}`);
 
-    // 2. Connecter le client
     console.log(`${COLORS.yellow}Connexion du client MCP...${COLORS.reset}`);
     const transport = new StdioClientTransport({
       command: 'node',
       args: [serverScriptPath],
     });
-    client = McpClient.create({
-        transport: transport,
-        clientInfo: {
-            name: 'quickfiles-test-harness',
-            version: '1.0.0',
-        }
+    client = new McpClient({
+        name: 'quickfiles-test-harness',
+        version: '1.0.0',
     });
 
     await client.connect(transport);
     console.log(`${COLORS.green}âœ“ Client connectÃ© avec succÃ¨s au serveur!${COLORS.reset}`);
 
-    // 3. ExÃ©cuter les tests (Test de fumÃ©e)
     console.log(`${COLORS.yellow}ExÃ©cution du test de fumÃ©e: list_tools...${COLORS.reset}`);
     const toolsResponse = await client.listTools();
     
     assert(toolsResponse.tools, 'La rÃ©ponse doit contenir une liste d\'outils');
-    assert(Array.isArray(toolsResponse.tools), 'La liste des outils doit Ãªtre un tableau');
-    assert(toolsResponse.tools.length > 0, 'La liste des outils ne doit pas Ãªtre vide');
-    
     const toolNames = toolsResponse.tools.map(t => t.name);
     console.log(`${COLORS.green}âœ“ Outils disponibles: ${toolNames.join(', ')}${COLORS.reset}`);
+    assert(toolNames.includes('read_multiple_files'), 'L\'outil "read_multiple_files" doit Ãªtre prÃ©sent');
+    assert(toolNames.includes('edit_multiple_files'), 'L\'outil "edit_multiple_files" doit Ãªtre prÃ©sent');
     assert(toolNames.includes('list_directory_contents'), 'L\'outil "list_directory_contents" doit Ãªtre prÃ©sent');
+    assert(toolNames.includes('restart_mcp_servers'), 'L\'outil "restart_mcp_servers" doit Ãªtre prÃ©sent');
 
     console.log(`${COLORS.green}âœ“ Test de fumÃ©e rÃ©ussi!${COLORS.reset}`);
 
-    // 4. ExÃ©cuter les tests fonctionnels
-    try { await testReadMultipleFiles(client); } catch (e) { console.error('--- ERREUR dans testReadMultipleFiles ---', e); }
-    try { await testListDirectory(client); } catch (e) { console.error('--- ERREUR dans testListDirectory ---', e); }
-    try { await testDeleteFiles(client); } catch (e) { console.error('--- ERREUR dans testDeleteFiles ---', e); }
-    try { await testEditMultipleFiles(client); } catch (e) { console.error('--- ERREUR dans testEditMultipleFiles ---', e); }
+    await testReadMultipleFiles(client);
+    await testListDirectory(client);
+    await testEditMultipleFiles(client);
+    await testEditMultipleFiles_CreateMode(client);
+    await testRestartMcpServers(client);
 
    } catch (error) {
-    console.error(`${COLORS.red}âœ— Un test a Ã©chouÃ©: ${error.message}${COLORS.reset}`);
+     console.error(`${COLORS.red}âœ— Un test a Ã©chouÃ©: ${error.message}${COLORS.reset}`);
     console.error(error.stack);
-    process.exitCode = 1; // Indiquer une sortie avec erreur
+    process.exitCode = 1;
   } finally {
         if (client) {
             await client.close();
